# HOG特征

1. Histogram of Oriented Gradient， 方向梯度直方图

2. 在一副图像中，局部目标的表象和形状（appearance and shape）能够被梯度或边缘的方向密度分布很好地描述。（本质：梯度的统计信息，而梯度主要存在于边缘的地方）。

3. 实现方式：首先将图像分成小的连通区域，我们把它叫细胞单元。然后采集细胞单元中各像素点的梯度的或边缘的方向直方图。最后把这些直方图组合起来就可以构成特征描述器。

4. 提高性能：把这些局部直方图在图像的更大的范围内（我们把它叫区间或block）进行对比度归一化（contrast-normalized），所采用的方法是：先计算各直方图在这个区间（block）中的密度，然后根据这个密度对区间中的各个细胞单元做归一化。通过这个归一化后，能对光照变化和阴影获得更好的效果。

5. 优点：由于HOG是在图像的局部方格单元上操作，所以它对图像几何的和光学的形变都能保持很好的不变性，这两种形变只会出现在更大的空间领域上。其次，在粗的空域抽样、精细的方向抽样以及较强的局部光学归一化等条件下，只要行人大体上能够保持直立的姿势，可以容许行人有一些细微的肢体动作，这些细微的动作可以被忽略而不影响检测效果。因此HOG特征是特别适合于做图像中的人体检测的

   ![img](D:\PaperReading\other\assets\122015115496401.png)

   ### 实现步骤

   1. **图像归一化**：归一化图像的主要目的是提高检测器对光照的鲁棒性，可以使用gama校正

   2. **利用一阶微分计算图像梯度**

      1. **图像平滑**：对于灰度图像，一般为了去除噪点，所以会先利用离散高斯平滑模板进行平滑：高斯函数在不同的尺度下进行对灰度图像进行平滑操作，Dalal等实验表明，人体检测效果最佳（即不做高斯平滑），使得错误率缩小了约一倍。不做平滑操作，可能原因：图像时基于边缘的，平滑会降低边缘信息的对比度，从而减少图像中的信号信息。

      2. **梯度法求图像梯度**：一阶微分处理一般对灰度阶梯有较强的响应。用一阶微分模板计算X,Y两个方向的梯度值，绝对值相加求梯度的近似值
         $$
         \Delta f = |Gx|+|Gy|
         $$
         梯度方向的计算,一般采用无符号的范围，因此小于0的加上 π ：
         $$
         \theta(x,y) = arctan(Gx/Gy)
         $$

         $$
         \theta(x,y) = 
         \begin{cases}
         	\theta(x,y)+ \pi, & \theta(x,y)<0\\
         	\theta(x,y) & others
         \end{cases}
         $$

      3. **基于梯度幅值的方向权重投影**：

         1. HOG结构：矩形HOG(R-HOG), 圆形HOG和中心环绕HOG，单位都是Block

      4. 每个Cell独立做梯度方向统计，得到一个向量，对于每个block进行归一化，使用L2-norm归一化

      5. 得到一个最终的HOG特征向量，大小为a\*b\*c，a表示每个cell中方向单元bin的数目，b表示block个数，c表示每个block中有几个cell

      6. Dalal提出的Hog特征提取的过程：把样本图像分割为若干个像素的单元（cell），把梯度方向平均划分为9个区间（bin），在每个单元里面对所有像素的梯度方向在各个方向区间进行直方图统计，得到一个9维的特征向量，每相邻的4个单元构成一个块（block），把一个块内的特征向量联起来得到36维的特征向量，用块对样本图像进行扫描，扫描步长为一个单元。最后将所有块的特征串联起来，就得到了人体的特征。例如，对于64*128的图像而言，每16*16的像素组成一个cell，每2*2个cell组成一个块，因为每个cell有9个特征，所以每个块内有4*9=36个特征，以8个像素为步长，那么，水平方向将有7个扫描窗口，垂直方向将有15个扫描窗口。也就是说，64*128的图片，总共有36*7*15=3780个特征。

      ## Gamma校正

      假设图像中有一个像素，值是 200 ，那么对这个像素进行校正必须执行如下步骤： 

      　　1. 归一化 ：将像素值转换为  0 ～ 1  之间的实数。 算法如下 : ( i + 0. 5)/256  这里包含 1 个除法和 1 个加法操作。对于像素  A  而言  , 其对应的归一化值为  0. 783203 。 

      　　2. 预补偿 ：根据公式  , 求出像素归一化后的 数据以  1 /gamma  为指数的对应值。这一步包含一个 求指数运算。若  gamma  值为  2. 2 ,  则  1 /gamma  为  0. 454545 , 对归一化后的  A  值进行预补偿的结果就 是  0. 783203 ^0. 454545 = 0. 894872 。 

      　　3. 反归一化 ：将经过预补偿的实数值反变换为  0  ～  255  之间的整数值。具体算法为 : f*256 - 0. 5  此步骤包含一个乘法和一个减法运算。续前 例  , 将  A  的预补偿结果  0. 894872  代入上式  , 得到  A  预补偿后对应的像素值为  228 , 这个  228  就是最后送 入显示器的数据。  

      　　如上所述如果直接按公式编程的话，假设图像的分辨率为 800*600 ，对它进行 gamma 校正，需要执行 48 万个浮点数乘法、除法和指数运算。效率太低，根本达不到实时的效果。 

      　　针对上述情况，提出了一种快速算法，如果能够确知图像的像素取值范围  , 例如  , 0 ～ 255 之间的整数  , 则图像中任何一个像素值只能 是  0  到  255  这  256  个整数中的某一个 ; 在  gamma 值 已知的情况下  ,0 ～ 255  之间的任一整数  , 经过“归一 化、预补偿、反归一化”操作后 , 所对应的结果是唯一的  , 并且也落在  0 ～ 255  这个范围内。

      　　如前例  , 已知  gamma  值为  2. 2 , 像素  A  的原始值是  200 , 就可求得 经  gamma  校正后  A  对应的预补偿值为  228 。基于上述原理  , 我们只需为  0 ～ 255  之间的每个整数执行一次预补偿操作  , 将其对应的预补偿值存入一个预先建立的  gamma  校正查找表 (LUT:Look Up Table) , 就可以使用该表对任何像素值在  0 ～ 255  之 间的图像进行  gamma  校正。 