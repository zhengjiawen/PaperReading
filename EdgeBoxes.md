## EdgeBoxes

### Abstract

1. 目标建议的使用是近年来提高目标检测计算效率的一种有效方法。
2. 我们提出了一种利用边缘生成对象边界框的新方法。
3. 边缘提供了图像的稀疏但信息丰富的表示。
4. 我们的主要观察是，完全包含在包围框中的轮廓数表示包含对象的框的可能性。
5. 我们提出了一个简单的框对象得分，它度量框中存在的边的数量减去那些与框的边界重叠的轮廓的成员。
6. 使用高效的数据结构，可以在几分之一秒内评估数百万个候选框，返回数千个得分最高的建议的排序集。
7. 使用标准度量，我们显示的结果明显比当前最先进的更准确，同时计算速度更快。
8. 特别是，在1000个建议的情况下，我们在0.5的重叠阈值下实现了96%以上的对象recall，在0.7的重叠阈值下实现了75%以上的recall。

### Introduction

1. 对象检测的目的是确定一个对象是否存在于一个图像中，如果存在，则在图像中的什么位置出现。
2. 在过去的十年里，解决这个问题的主要方法是滑动窗口模式，在这种模式下，对象分类在图像的每个位置和尺度上执行.
3. 最近，提出了一种新的目标检测框架。首先生成一组对象边界框建议，目的是减少需要进一步分析的位置集，而不是在每个图像位置和比例上搜索对象。
4. 这些方法的显著发现是，可以以一种与被检测的对象类型无关的方式精确地生成对象建议。
5. 对象建议生成器目前被几种最先进的对象检测算法使用，其中包括2013年ImageNet检测挑战的获胜者和PASCAL VOC数据集上的顶级方法。
6. 高回忆率和高效率是对象建议生成器的关键属性.如果没有在对象附近生成建议，则无法检测该对象。
7. 一个有效的生成器能够使用相对较少的候选边界框(每个图像的范围通常在数百到数千之间)获得较高的回忆率。
8. 提案生成器的精度不那么重要，因为生成的提案数量只占滑动窗口方法通常考虑的候选项总数的很小一部分(滑动窗口方法可能对每个对象类别的数万到数十万个位置进行评估)。
9. 由于对象建议生成器主要用于减少检测器的计算成本，因此它们应该比检测器本身快得多
10. 有人猜测，使用少量的目标建议甚至可能由于减少假阳性而提高检测准确性
11. 本文提出了一种直接从边缘生成对象边界框的新方法——边缘框
12. 与段相似，边缘提供了图像的简单但信息丰富的表示。
13. 事实上，一幅图像的线形图仅使用一小部分信息就可以准确地传达图像所包含的高级信息
14. 正如我们所演示的，边缘的使用提供了许多计算优势，因为它们可以有效地计算，并且得到的边缘映射是稀疏的。
15. 在这项工作中，我们研究如何直接检测对象的建议从边缘地图。
16. 我们的主要贡献是以下的观察:**完全被包围在一个包围框中的轮廓的数量表明了包含一个对象的框的可能性**
17. **如果属于轮廓的所有边缘像素都位于盒子的内部，我们说轮廓是完全被盒子包围的**
18. 边缘往往与对象边界相对应，因此，紧紧包围一组边缘的框可能包含一个对象
19. 然而，位于对象的边框内的一些边可能不是所包含对象的一部分。
20. 具体来说，属于跨越框边界的轮廓的边缘像素可能对应于框外的对象或结构，请参见图1。
21. 在这篇论文中，我们证明了**根据一个盒子完全包围的轮廓数**来评分，可以创建一个非常有效的建议措施。
22. 相比之下，仅仅计算框内边缘像素的数量并不能提供足够的信息。
23. 我们的方法与[4]引入的超像素跨界测量方法有一些相似之处;然而，我们没有测量跨界等高线的数量，而是把这种等高线从考虑中去掉。
24. 由于图像中可能的边界框数量很大，我们必须能够有效地对候选框进行评分。
25. 我们利用[16,19]中最近提出的快速且公开的**结构化边缘检测器**来获取初始边缘映射。
26. 为了在以后的计算中提供帮助，相似方向的相邻边缘像素被聚在一起形成组。
27. **根据边缘群的相对位置和方向计算边缘群之间的亲缘关系**，使得形成长连续轮廓的群具有较高的亲缘关系。
28. **一个盒子的得分是通过将盒子内所有边缘组的边缘强度相加，减去跨盒子边界的轮廓的一部分边缘组的强度计算出来的**，见图1。
29. 我们使用滑动窗口方法评估候选框，类似于传统的对象检测。
30. 在每一个潜在的物体位置，比例和长宽比，我们产生一个分数表明一个物体存在的可能性。
31. 使用简单的从粗到细的搜索进一步细化有希望的候选框
32. 利用有效的数据结构，我们的方法能够快速地从数百万潜在候选者中找到最佳的目标建议。
33. 我们展示了改进的召回率超过最先进的方法，为广泛的交叉超过联合阈值，同时提高效率。
34. 特别是在PASCAL VOC数据集[15]上，只要给出1000条建议，我们就可以在0.5的重叠阈值下实现96%以上的对象召回，在0.7的重叠阈值下实现75%以上的对象召回。
35. 在后一种更具挑战性的情况下，以前的先进方法需要更多的建议来实现类似的召回。
36. 我们的方法在四分之一秒内运行，而一种几乎实时的变体在十分之一秒内运行，只是在准确性上略有损失。

### Rekated work

1. 生成对象建议的目标是创建一组相对较小的候选边界框，用于覆盖图像中的对象。
2. 这些建议最常见的用途是允许使用复杂而昂贵的分类器进行特殊对象检测.
3. 另一个流行的应用是弱监督学习[20,21]，通过限制候选区域的数量，在较少监督的情况下学习变得可行
4. 对于检测，回忆(recall)是关键的，可以使用数千个候选项，对于弱监督学习，通常每个图像保留几百个建议。
5. 自从几年前创建以来[4,9,6]，对象建议生成已经发现了广泛的适用性
6. 生成对象建议的目的是实现图像分割的许多好处，而不必解决将图像显式划分为不重叠区域的难题。
7. 虽然分割在目标检测[22]中取得了有限的成功，但总体上它不能提供准确的目标区域。
8. 提升姆等人[23]提出利用多个重叠分段来克服单个分段的误差，[24]和[25]在对象检测的背景下对此进行了进一步的探索
9. 虽然使用多个分段提高了鲁棒性，但构建一致的分段是一项固有的困难任务。对象建议生成通过直接生成多个重叠的对象建议来避免完全分割的挑战。
10. 针对对象提案生成，出现了三种不同的范例。
11. 表示对象建议的候选边界框可以通过测量它们的“objectness”[4,11]、生成图像的多个前景-背景分割[6,9,10]或合并超像素来找到
12. 我们的方法提供了一个基于边的替代框架，它既简单又高效，同时与以前的工作共享许多优势。
13. 下面我们简要概述每种范式的代表性工作;我们建议读者参考Hosang etal对对象建议方法进行全面的调查和评估。
14. **Objectness Scoring**：Alexe et al.[4]等人提出，通过在分类框架中组合若干线索，并为每个建议分配一个结果“objectness”评分，来对候选人进行排名。
15. [7]基于这一思想，通过学习有效的级联来更快更准确地对候选对象排序。
16. 在多个线索中，[4]和[7]都是基于窗口边界附近的边缘分布来定义分数的。
17. 然而，这些边缘分数并不能去除与盒子边界相交的等高线的边缘，我们发现这是非常关键的。
18. [4]利用超像素跨界测量惩罚包含重叠边界段的候选。
19. 相反，我们通过在可能不直接位于边界上的边缘组之间传播信息来抑制跨界轮廓。
20. 最后，[11]提出了一种基于图像梯度的快速目标度评分方法。
21. **Seed Segmentation**:[6, 9, 10]都是从多个种子区域开始，为每个种子生成单独的前景-背景分割。
22. 这些方法的主要优点是生成高质量的分割掩码，缺点是计算成本高(每幅图像的分钟数)。
23. **Superpixel Merging**:选择搜索[5]是基于从[27]计算多个基于超像素的分层分割，并在其周围放置边界框。
24. 选择性搜索被近年来的top detection methods所广泛使用[5,12,13]，其成功的关键是相对较快的速度(每张图像的秒数)和较高的查全率
25. 同样，[8]提出了一种随机贪婪算法，用于计算可能同时出现的超像素集。
26. 在我们的工作中，我们操作的是一组边缘，而不是超像素。
27. 边缘可以被概率地表示，具有相关的方向信息，并且可以被链接以允许信息的传播;适当地利用这些额外的信息，可以在准确性上获得很大的提高。
28. 据我们所知，我们的方法是第一个**直接从边缘生成对象边界框建议**。
29. 与之前的所有方法不同，我们不使用分割或超像素，也不需要从多个线索学习评分函数。
30. 相反，我们建议根据完全由包围框包围的轮廓数对候选框进行评分。
31. 令人惊讶的是，这种概念上简单的方法与以前的方法相比有显著的优势。

### Approach

1. 在本节中，我们将描述寻找对象建议的方法。对象建议的排名是**基于从完全包围在候选边界框中的轮廓计算出的单一分数**。

2. 首先，我们描述一种基于边缘组的数据结构，它允许完全封闭的轮廓线与不封闭的轮廓线进行有效的分离。

3. 接下来，我们定义基于边缘的评分函数。最后，我们详细介绍了寻找顶级对象建议的方法，这些建议使用滑动窗口框架对位置、比例和纵横比进行评估，然后使用简单的从粗到细的搜索进行细化。

4. 给定一幅图像，我们首先计算每个像素的边缘响应。使用结构化边缘检测器[16,19]可以发现边缘响应，该检测器在预测对象边界方面表现出良好的性能，同时也非常高效。

5. 我们使用单尺度的变体和[19]中引入的锐化增强来减少运行时间。考虑到密集的边缘响应，我们进行与边缘响应正交的非极大抑制(Non-Maximal Suppression, NMS)来寻找边缘峰值，如图1所示。

6. 结果是一个稀疏的边缘映射，每个像素的**边缘大小为mp**，方向为 theta p。我们将边缘定义为mp > 0.1像素(为了计算效率，我们对边缘进行阈值)。轮廓被定义为一组形成连贯边界、曲线或直线的边。

   #### Edge groups and affinities

   1. 如图1所示，我们的目标是识别与边界框边界重叠的轮廓，因此这些轮廓不太可能属于边界框所包含的对象
   2. 给定一个框b，我们通过计算每个p属于b 且 mp > 0.1的框边界上的边的最大度来识别这些边。
   3. 直观上，直线连接的边具有较高的粗度，而没有被高曲率轮廓连接或连接的边具有较低的亲和力。
   4. 为了提高计算效率，我们发现**对边缘度(affinity)高且只计算边缘组之间的关系的边进行分组**是有好处的
   5. 我们**使用一种简单的贪心方法来组合8连通边，直到它们的方向差之和超过阈值**(pi/2)。
   6. **小的组与相邻的组合并**。边缘组的说明如图1第3行所示。
   7. ***<u>什么是小的组，怎么定义，代码中有个EdgeMergeThreshold参数，设为0.5，这个值指的是edge group的和吗</u>***
   8. 给定一组边群 si属于S，我们计算每对相邻群之间的亲缘关系。
   9. **对于si和sj对，亲和力的计算是基于它们的平均位置xi和xj，以及thetai和thetaj的平均方向**。
   10. 从直觉上讲，如果组间的夹角与组的方向相似，那么边缘组的倾角就很高。
   11. 公式： 见论文公式（1）    
   12. **<u>问题： 论文中讲的，两个group的方向越接近直线，相似度（affinity）越高，a(si,sj)越大，当theta ij=0的时候，affinity的值仍取决于方向角度的值，不一定是最大的，这是为什么呢</u>**
   13. r的值可以用来调整亲和力对方向变化的敏感性，训练中使用r= 2
   14. 如果**两个边缘组之间的距离超过2个像素，则它们的亲和力设置为零**。
   15. 为了提高计算效率，只存储小阈值(0.05)以上的亲和力，其余的假设为零。
   16. 边缘分组和亲和度量在计算上是微不足道的。实际结果对边缘分组的细节具有鲁棒性

   #### Bounding box scoring

   1. 给定边界组S的集合及其亲缘关系，我们可以计算任意候选边界框b的对象建议得分。

   2. 为了找到我们的分数，我们首先计算组si中所有边p的mi和。

   3. 我们还在每组si中选择一个像素p的任意像素位置 
      $$
      x_i^{-}
      $$

   4. 正如我们将要展示的，p属于si的确切选择并不重要。

   5. 对于每个group si， 我们计算一个连续值 wb(si) belong to [0,1], 这表明， 如果si完全在box b中，wb=1， 否则 wb=0

   6.  设Sb是与盒子b的边界重叠的边组的集合

   7. 我们寻找Sb使用3.3节中描述的有效数据结构

   8. 对于所有的si belong to Sb, wb设为0

   9. 类似的，对于所有wb=0的si， 存在像素不在b中，因此他的所有像素要不在b之外，要不属于sb

   10. 对于剩下的edge group，他们的任意像素都属于b并且si not belong to Sb, 我们计算wb如下：
       $$
       W_b (s_i)=1-max_{T} \prod_{j}^{|T|-1} a(t_j, t_{j+1})
       $$
       

   11. T是指从框框的边缘开始到达si的edge group序列集合

   12. 如果没有这么一条路径存在，我们define wb(si)=1

   13. 因此，式(2)求出边缘组si与重叠盒边界的边缘组之间亲和力最高的路径。由于大多数成对的亲缘关系都是零，因此可以有效地实现这一点。

   14. 使用计算值的wb，我们定义我们的分数使用:
       $$
       h_b = \frac {\sum_i {w_b(s_i)m_i}} {2(b_w+b_h)^k}
       $$
       

   15. bw 和bh 是box的宽和高。注意，我们要除以盒子的周长，而不是它的面积，因为无论大小，边缘的宽度都是一个像素

   16. ***问题：<u>从上面可知，没有路径存在时wb=1，路径上的edge group的相似度越大，累乘之后的值越大，因此wb越小，那么根据hb的公式，box的宽高确定，每个edge group的边缘强度m确定，hb相当于边缘强度的加权，因此wb越小，hb也越小，包括下面的hbin越小，分数越低？？？</u>***

   17. 然而，k = 1.5的值在平均上被用来抵消较大的窗口有的更多的边缘的偏差。

   18. 在实际应用中，我们使用积分图像来加速(3)式中分子的计算

   19. 积分图像被用来计算在b中的mi的和

   20. 另外，对于所有处于b中且wb(si) < 1 ,(1-wb(si))mi 从这个和众减去

   21. 这大大加快了计算速度，因为通常对于大多数si, wb(si) = 1，而不需要显式地考虑所有此类si。

   22. 最后，我们观察到盒子中心的边缘没有靠近盒子边缘的边缘重要

   23. 为了解释这个观察结果，我们可以从以b为中心的盒子bi中减去边缘大小:
       $$
       h_b^{in} = h_b -\frac {\sum_{p-belong-bin}{m_p}} {2(b_w+b_h)^k}
       $$
       

   24. 利用积分图像可以有效地计算bi中边缘大小的和。

   25. 如第4节所示，我们发现hin在最小的额外计算成本下比hb提供了稍微更好的准确性。

   #### Find intersecting edge groups

   1. 在上一节中，我们假设与盒子b的边界重叠的边组Sb的集合是已知的。
   2. 由于我们计算了大量的边界框(第3.4节)，找到Sb的有效方法至关重要。
   3. 一些简单的方法，如彻底搜索框边界上的所有像素，会非常昂贵，特别是对于大型框。
   4. 我们提出了一种有效的方法，依赖于两个附加数据结构,为边界框的每边找到相交的边缘组。
   5. 下面，我们描述了从像素(c0;r)到(c1;r)，在一个水平的边界中找到交叉点的过程
   6. 垂直边界可以用类似的方式处理。
   7. 对于水平边界，我们为图像的每一行创建两个数据结构
   8. 第一个数据结构存储行r的边组索引的有序列表Lr。
   9. 列表是通过存储沿行r出现的边缘组的顺序创建的。
   10. 只有当边缘组索引从一个像素变化到下一个像素时，才会向Lr添加索引。
   11. 结果是Lr的大小远远小于图像的宽度。
   12. 如果边缘组之间的像素不是边缘，则向列表中添加0。
   13. 创建与图像宽度相同大小的第二个数据结构Kr，它为行r中的每一列c存储相应的索引到Lr中。
   14. 因此，如果像素p在位置(c;r)是边组si的一个成员， Lr(Kr(c))=i
   15. 由于大多数像素不属于边缘组，利用这两种数据结构，我们可以通过搜索从索引Kr(c0)到Kr(c1)的Lr有效地找到重叠边缘组的列表。

   #### Search strategy

   1. 在搜索对象建议时，需要考虑对象检测算法
   2. 一些检测算法可能需要高精度的目标建议,而另一些算法对边界框放置的错误具有更大的容忍度。
   3. 边界框的精度通常使用IoU来度量
   4. IoU计算候选框与地面真值框的交集除以它们的并集的面积。
   5. 在评估对象检测算法时，通常使用0.5的IoU阈值来判断检测是否正确
   6. 然而，如图2所示，0.5的IoU分数非常松散。
   7. 即使是基于ground truth的0.5 IoU生成的object proposal，检测算法也可能会给出一个较低的分数。
   8. 因此，通常希望IoU分数大于0.5
   9. 在本节中，我们将描述一种基于探测器所需的IoU, sigma,的对象建议搜索策略。
   10. 对于sigma的高值，我们在可能包含对象的区域附近生成一组密度更高的边界框。
   11. 对于sigma的低值, boxes可以有更高的多样性，因为我们假设目标检测器可以在盒子的位置上产生中等程度的误差。
   12. 因此，我们提供了一个折衷方案，即在找到数量较少但精度较高的对象和数量较多但精度较低的对象之间进行权衡。
   13. 请注意，以前的方法有一个隐含的偏见，他们是为sigma设计的，例如,对象[4]和随机Prim[8]分别针对低s和高s进行了调优，而我们提供了对多样性和准确性的显式控制。
   14. 我们开始搜索候选边界框使用滑动窗口搜索的位置，规模和长宽比。
   15. 每个步骤的大小是使用单个参数 alpha确定的，该参数表示和相邻框的IoU。
   16. 也就是说，平移、缩放和宽高比中的步长是确定的，这样一步就会导致相邻的盒子有一个IoU为alpha
   17. 缩放值的范围从a = 1000像素的最小框面积到完整的图像。
   18. 纵横比从1/t 到t不等，实际中使用的是t= 3。
   19. 正如我们在第4节中讨论的，对于sigma的大多数值，alpha= 0.65是理想的。
   20. 然而，如果需要sigma（IoU） > 0.9, alpha必须增加到0.85
   21. 在执行滑动窗口搜索之后，将细化得分hbin在一个小阈值以上的所有边界框位置。
   22. 采用贪婪迭代搜索的方法来实现h在位置、比例和纵横比上的最大化。
   23. 每次迭代之后，搜索步长减少一半。
   24. 一旦平移步长小于2像素，搜索将停止。
   25. 一旦候选边界框被细化，它们的最大分数将被记录并排序。
   26. 我们的最后一个阶段对排序后的框执行非最大抑制(NMS)。
   27. 对于得分较高的盒子，如果其IoU大于beta，则移除盒子
   28. 我们发现，在实践中，设置beta=theta +0.05在第4节theta的所有值上都具有很高的准确性。

### Result

#### Approach variant

1. 用hb而不用hbin，准确率会有小幅下降
2. 本文的主要贡献在于，在计算框的分数时，需要去除与框边界重叠的轮廓，不移除的话，准确率大幅下降
3. 初始边缘检测器的质量也很重要，fig 4 对比了几种边缘检测器
4. 如果初始边缘映射是使用基于梯度的Canny边缘[28]生成的，而不是使用结构化边缘[16]生成的，那么结果会降低。
5. 如果计算的是多尺度结构边而不是单尺度结构边，则精度增益最小。
6. 由于可以更方便地计算单尺度边缘，我们对所有剩余的实验都使用单尺度边缘。
7. 基线方法使用单尺度边缘，运行时间为0.25秒。
8. 如果需要接近实时的性能，可以调整算法的参数，最多返回1000个box，精度损失较小。
9. 具体来说，我们可以将alpha降低到0.625，并将用于确定要细化哪些框的阈值从0.01提高到0.02。
10. 最后，如果我们也禁用结构化边缘检测器[19]的锐化增强，我们的算法的运行时间是0.09s。
11. 如图4(d)所示，这种称为Edge Boxes Fast的变体在返回少于1000个box时几乎有相同的结果。

#### Comparison with state-of-the-art

1. 图5(顶部)显示了针对不同IoU阈值改变目标建议数时的检出率
2. Edge Boxes在所有IoU值和小数目和大数目的候选项上都表现良好。
3. 选择搜索[5]可以获得具有竞争力的准确性，特别是在较高的IoU值和较大的框数时
4. **CPMC**[6]生成高质量的提案，但产生的候选方案相对较少，因此无法实现高召回。
5. **BING**[11]的速度非常快，只能生成非常lossely的拟合建议，因此只在低IoU的情况下具有竞争力。
6. 相比之下，我们的方法在各种IoU阈值和目标建议数量方面取得了良好的效果
7. 事实上，如表2所示，要想在IoU为0.7的情况下实现75%的recall，EdgeBoxes需要800份提案，使用Selective Search需要1400份提案，以及使用Randomized Prim's 需要3000份提案。

